
"""
Поиск элементов с помощью CSS-селекторов
Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

id
tag
значение атрибута
name
class

Поиск осуществляется нажатием клавиши при открытой консоли ctr-f

Поиск по id
Какое везение! У элемента с нашей картинкой есть атрибут id="bullet", а значит,
мы однозначно можем найти её с помощью селектора #bullet (знак # означает,
что мы ищем по id со значением bullet).

Поиск по значению атрибута
Можно найти элемент, указав название атрибута и его значение.
Например, можно переписать поиск по id в следующем виде [id="bullet"] вместо #bullet.

Лучше использовать вариант с квадратными скобками при поиске значения
атрибута для тех атрибутов, у которых нет собственных коротких команд поиска.
Например, давайте найдем элемент h1 по значению его атрибута value: [value="Cat memes"].


Поиск по name
Этот вариант поиска является разновидностью поиска по значению атрибута и
записывается так же: [name="bullet-cat"]. Мы выделяем этот вариант потому
что он довольно часто используется, а также выделяется как отдельный вид поиска
элементов в Selenium WebDriver.


Поиск по class
Поиск по классу можно записать в виде [class="jumbotron-heading"],
так как class тоже является атрибутом элемента. Но раз уж классы используются
практически в каждой странице при задании стилей страниц, то для них также имеется
свой короткий вариант поиска: .jumbotron-heading. То есть мы пишем значение класса
и предваряем его точкой.

Вариант .lead при этом позволит найти данный элемент,
так как он ищет простое вхождение класса в элемент. Для уточнения селектора
можно задать также оба класса, для этого нужно добавить второй класс к строке поиска
без пробела и предварить его точкой: .lead.text-muted. Порядок классов в отличие от
первого способа здесь не важен — .text-muted.lead так же найдет нужный элемент.
Рекомендуем пользоваться вторым способом поиска классов, так как он является более гибким.
"""

"""
Поиск элементов с помощью составных CSS-селекторов

Попробуем найти элемент с текстом "Ходили купаться". 
Для решения этой задачи мы можем взять элемент, стоящий выше в иерархии нужного нам элемента, и написать следующий селектор:

#post2 .title
Здесь символ # означает, что надо искать элемент с id post2, 
пробел - что также нужно найти элемент-потомок, а ., что элемент-потомок 
должен иметь класс со значением title.

Использование дочерних элементов

Другой способ найти этот элемент:
#post2 > div.title
Здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент 
с тегом и классом: div.title, который находится строго на один уровень 
иерархии ниже чем элемент #post2. Для этого используется символ >

Использование порядкового номера дочернего элемента

Еще один способ найти этот элемент:
#posts > .item:nth-child(2) > .title
Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент 
среди дочерних элементов для #posts. Затем с помощью конструкции > .title мы указываем, 
что нам нужен элемент .title, родителем которого является найденный ранее элемент .item.


Использование нескольких классов

Также мы можем использовать сразу несколько классов элемента, 
чтобы его найти. Для этого классы записываются подряд через точку: .title.second

#moto       Поиск по ID
article     Поиск по tag
[title="one-thing"]    Поиск по attribute 
[name="moto"]          Поиск по name 
.lead                  Поиск по class 
article.text-muted.lead        Поиск по составному CSS-селектору 

"""
"""
2. Символ [ ] — это команда фильтрации
Если по запросу найдено несколько элементов, т
о будет произведена фильтрация по правилу, указанному в скобках.

Правил фильтрации очень много:

по любому атрибуту, будь то id, class, title (или любой другой). 
Например, мы хотим найти картинку с летящим котом, для этого можно 
выполнить запрос //img[@id='bullet']
по порядковому номеру. 
Допустим, мы хотим выбрать вторую по порядку карточку с котом. 
Для этого найдем элемент с классом "row" и возьмем его второго потомка: 
//div[@class="row"]/div[2]
по полному совпадению текста. Да, XPath — это единственный способ найти элемент 
по внутреннему тексту. Если мы хотим найти блок текста с котом-Лениным, 
можно воспользоваться XPath селектором //p[text()="Lenin cat"]. 
Такой селектор вернет элемент, только если текст полностью совпадет. 
Здесь важно сказать, что не всегда поиск по тексту — это хорошая практика, 
особенно в случае мультиязычных сайтов.
по частичному совпадению текста или атрибута.
Для этого нужна функция contains. Запрос //p[contains(text(), "cat")] 
вернет нам все абзацы текста, которые содержат слово cat. 
Точно так же можно искать по частичному совпадению других атрибутов, 
это удобно, если у элемента несколько классов. Посмотрите на код навбара 
сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]
в фильтрации еще можно использовать булевы операции (and, or, not) 
и некоторые простые арифметические выражения (но вообще не стоит, наверное). 
Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat", 
для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']
"""