"""
--------------------------------------Коды PostgreSQL--------------------------------
"""

"""
------------------------Создание таблицы

CREATE TABLE IF NOT EXISTS my_schema.books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(50),
    author VARCHAR(50),
    price DECIMAL(8, 2),
    stock INTEGER
);

------------------------Заполнение данными

INSERT INTO my_schema.books (title, author, price, stock)
VALUES
    ('1984', 'Джордж Оруэлл', 15.99, 20),
    ('Гордость и предубеждение', 'Джейн Остин', 12.99, 30),
    ('Мастер и Маргарита', 'Михаил Булгаков', 19.99, 15),
    ('Война и мир', 'Лев Толстой', 29.99, 10),
    ('Граф Монте-Кристо', 'Александр Дюма', 24.99, 25),
    ('Ромео и Джульетта', 'Уильям Шекспир', 9.99, 40),
    ('Анна Каренина', 'Лев Толстой', 25.99, 12),
    ('Дон Кихот', 'Мигель де Сервантес', 22.99, 18),
    ('Идиот', 'Фёдор Достоевский', 16.99, 28),
    ('Собака Баскервилей', 'Артур Конан Дойл', 14.99, 32);
    
-------------------------------
CREATE TABLE users (
    id INTEGER,                 // Только целые числа
    name VARCHAR(50),           // Только текстовые символы
    email VARCHAR(100),         // Строго формат почты
    age SMALLINT,               // Только числа возраста
    salary NUMERIC(10,2),       // Число с копейками
    registration_date DATE,     // Только дата
    is_active BOOLEAN           // Только true/false
);



------------------------------
типы даных

integer - числовое хранение данных
smallint - (-32768 до 32768)
real - 3,141414 (6 знаков после запятой)
double precision (15 знаков после запятой)
char - (строка фиксированной длины)
varchar(100) - (max 100 символов)
text - (строка произвольной длины)
date - (2025-09-06)
time - (16:56:45)
boolean - (True, False)
point - (точку с координатами x,y)

CREATE TABLE - создавать, удалять таблицы




---------------DDL создание таблицы

CREATE TABLE public.rrr (
	id serial4 NOT NULL,
	"name" text NULL,
	department int4 NULL,
	salary numeric NULL,
	hare_date date NULL,
	CONSTRAINT rrr_pkey PRIMARY KEY (id)
);

----------------DML заполнение таблицы

insert into rrr (name, department, salary)
values ('Alice', 1, 2000.0);

внести изменения
update rrr set salary = 1000;

посмотреть результат
select * from rrr r;

удалить данные
delete from rrr;

--------------DCL (назначать права у начальника одни у инженера другие)

--------------TCL (транзакции)
"""

"""
-------------------------------------------------------------------------------------
В рамках этого блока мы рассмотрим самый часто встречающийся оператор в SQL — SELECT.
-------------------------------------------------------------------------------------

SELECT что_выбрать FROM откуда_выбрать;
SELECT * FROM books;

Если нам нужны только определенные столбцы, мы перечисляем их через запятую:
SELECT id, title, author FROM books;

SELECT b.id,
       b.title,
       b.author
FROM books b;

Алиас в SQL — это временное имя, которое мы присваиваем таблице или столбцу в запросе. 
Это делается для того, чтобы упростить обращение к ним в запросе. 
В нашем случае b — это алиас для таблицы books. Это означает, что вместо того, 
чтобы писать books.id, мы можем просто писать b.id.


SELECT b.id
,b.title
,b.author
FROM books b;

можно так


Поскольку мы пока работаем с одной несвязанной таблицей, указание схемы 
не является обязательным и это не будет считаться ошибкой. 
Однако правилом хорошего тона является явное указание схемы, 
что обеспечивает ясность и точность в запросах.

SELECT b.id
,b.title
,b.author
FROM my_schema.books b;

Например,  в таблице books есть две книги, автором которой является Лев Толстой. 
Если мы захотим вывести только уникальных авторов и применим оператор DISTINCT — 
тогда запрос выведет только первое значение.

SELECT distinct b.author
FROM my_schema.books b;
"""


"""
*******************************************************************************************
                        математические операции
*******************************************************************************************

1. Сложение:
select 2 + 3 as "сумма чисел 2 и 3"

2. Вычитание:
select 10 — 5 as "разность чисел 10 и 5"

3. Умножение:
select 4 * 5 as "произведение чисел 4 и 5"

4. Деление:
select 10 / 2 as "отношение чисел 10 и 2"

5. Остаток от деления:
select 7 % 3 as "остаток от деления"

6. Возведение в степень:
select 2 ^ 3 AS "2 в 3 степени"

Вычислим общую стоимость каждой книги. Для этого нам нужно найти произведение 
цены одной книги и количества экземпляров.
---------------------------------
select b.title as "alias"
,b.price * b.stock as total
from my_schema.books b;

сколько будет в рублях
-------------------------------
select b.title as "alias"
,b.price as "usd"
,b.price * 80 as "rub"
from my_schema.books b

НДС
------------------------------
select b.title as "alias"
,b.price as "цена с НДС"
,b.price / 1.2 as "цена без НДС"
from my_schema.books b

select b.title as "alias"
,b.price as "цена с НДС"
,round(b.price / 1.2, 2) as "цена без НДС"
from my_schema.books b


*******************************************************************************************
                        математические функции
*******************************************************************************************
Благодаря математическим функциям PostgreSQL, такие задачи как вычисление квадратных корней,
обработка логарифмов и проведение статистического анализа, становятся простыми.


ABS(X)	        | Абсолютное значение	                            |ABS(-5)	|5
-----------------------------------------------------------------------------------------
RANDOM()	    | Генерирует случайное число с плавающей запятой    |RANDOM()
                | в диапазоне от 0 (включительно) до 1              |любое число от 0
                |(исключительно)	                                |, не включая 1
------------------------------------------------------------------------------------------
SQRT(X)	        |Возвращает квадратный корень из заданного числа	|SQRT(16)	|4
------------------------------------------------------------------------------------------
CBRT(X)	        |Возвращает кубический корень из заданного числа	|CBRT(27)	|3
------------------------------------------------------------------------------------------
POWER(X, n)	    |Возводит число в степень другого числа	            |POWER(2, 3)	|8
------------------------------------------------------------------------------------------
EXP(X)	        |Возвращает значение e возведенное в степень 
                |заданного числа	                                |EXP(X)	|2.718281828459045
-------------------------------------------------------------------------------------------
PI()	        |Математическая константа π (пи)	                |PI()	|3.141592653589793
-------------------------------------------------------------------------------------------
DEGREES(X)	    |Преобразует угол, заданный в радианах, в градусы	|DEGREES(PI())	|180
-------------------------------------------------------------------------------------------
RADIANS(X)	    |Преобразует угол, заданный в градусах, в радианы	|RADIANS(180)	|3.141592653589793
-------------------------------------------------------------------------------------------
ROUND(X, n)	    |Округления числового значения до заданного 
                |количества знаков после запятой	                |ROUND(3.14, 1)  |	3.1
-------------------------------------------------------------------------------------------
FLOOR(X)	    |Округление до ближайшего наименьшего целого числа	|FLOOR(17.36)	|17
-------------------------------------------------------------------------------------------
CEIL/CEILING	|Округление до ближайшего наибольшего целого числа	|CEIL(4.3)	|5
-------------------------------------------------------------------------------------------
TRUNC(X)	    |Удаляет лишние знаки после запятой без округления 
                |на заданное количество	                            |TRUNC(3.789, 2)  |3.78
--------------------------------------------------------------------------------------------
SCALE(X)	    |Определяет количество знаков после запятой в 
                |дробной части числа	                            |SCALE(3.141592653589793)	|15
---------------------------------------------------------------------------------------------
LN(X)	        |Натуральный логарифм	                            |LN(10)	|2.302585092994046
-------------------------------------------------------------------------------------------
LOG(X, n)	    |Логарифм заданного числа	                        |LOG(100, 10)	|2
-------------------------------------------------------------------------------------------
MOD(X, Y)	    |Возвращает остаток от деления	                    |MOD(11, 4)	|3
-------------------------------------------------------------------------------------------
SIGN(X)	        |Возвращает одно из трех значений 1 — если число 
                |положительное, -1 — если число отрицательное
                |и 0 если число равно нулю.	                        |SIGN(5)	|1
-------------------------------------------------------------------------------------------
WIDTH_BUCKET    |
(expression,    |Делит числовые значения на равные интервалы (корзины) |WIDTH_BUCKET(5, 0, 10, 4) |3
min_value,      |в рамках заданного диапазона.                         |
max_value,      |
num_buckets)	 		
-------------------------------------------------------------------------------------------
TAN(X)	        |Возвращает тангенс числа	                        |TAN(1.75)	|-5.52037992250933
-------------------------------------------------------------------------------------------

*******************************************************************************************
                                    Строковые функции
*******************************************************************************************
Строковые функции — это набор инструментов, которые позволяют редактировать, 
форматировать и анализировать текстовые данные в SQL. Они используются 
для извлечения подстрок, замены символов, изменения регистра текста и многое другое.


---------------------------------------------------------------------------------------
BTRIM               |Удаляет все указанные символы как в начале, так и в конце строки.
---------------------------------------------------------------------------------------
CHAR_LENGTH         |Возвращает длину указанной строки.
---------------------------------------------------------------------------------------
CHARACTER_LENGTH    |Возвращает длину указанной строки.
---------------------------------------------------------------------------------------
INITCAP             |Преобразует первую букву каждого слова в верхний регистр, 
                    |а все остальные буквы преобразуются в нижний регистр.
---------------------------------------------------------------------------------------
LENGTH              |Возвращает длину указанной строки, выраженную количеством символов.
---------------------------------------------------------------------------------------
LOWER               |Преобразует все символы указанной строки в нижний регистр.
--------------------------------------------------------------------------------------
LPAD                |Возвращает строку, дополненную с левой стороны указанной 
                    |строкой определенной длины.
--------------------------------------------------------------------------------------
LTRIM               |Удаляет все указанные символы в левой части строки.
--------------------------------------------------------------------------------------
CONCAT              |Позволяет объединять 2 или более строк вместе.
--------------------------------------------------------------------------------------
POSITION            |Возвращает местоположение подстроки в строке.
--------------------------------------------------------------------------------------
REPEAT              |Повторяет строку указанное количество раз.
--------------------------------------------------------------------------------------
REPLACE             |Заменяет все вхождения указанной строки.
--------------------------------------------------------------------------------------
RPAD                |Возвращает строку, дополненную с правой стороны указанной 
                    |строкой определенной длины.
---------------------------------------------------------------------------------------
RTRIM               |Удаляет все указанные символы в правой части строки.
---------------------------------------------------------------------------------------
STRPOS              |Возвращает расположение подстроки в строке.
---------------------------------------------------------------------------------------
SUBSTRING           |Позволяет извлечь подстроку из строки.
---------------------------------------------------------------------------------------
TRANSLATE           |Используется для замены набора символов в строке на другой 
                    |набор символов. Она выполняет однотактное преобразование, 
                    |заменяя каждый символ из одного набора на соответствующий символ 
                    |из другого набора.
----------------------------------------------------------------------------------------
TRIM                |Удаляет все указанные символы из начала или конца строки.
----------------------------------------------------------------------------------------
UPPER               |Образует все символы в указанной строке в верхний регистр.


ПРИМЕРЫ

select substring('Hello World', 6, 6)
*ОТВЕТ: World

_____________________________________________________
SELECT CONCAT(title, ' — ', author) AS full_book_name
FROM books;
*объединение строк '-' разделитель

_____________________________________________________
SELECT b.title
,LOWER(b.title) AS lower_title
,UPPER(b.title) AS upper_title
FROM my_schema.books b;
*регистры

___________________________________________________________
select b.title
,REPLACE(b.title, '1984', '1984 год') AS new_title
from my_schema.books b
limit 1;
*замена

____________________________________________________________
select b.title
,LENGTH(b.title) title_length
from my_schema.books b
*длина строки

*****************************************************************************************
                                Даты и время
******************************************************************************************

В этой части мы поговорим о функциях даты и времени в PostgreSQL

----------------------------------------------------------------------------------------
CURRENT_DATE	    |Возвращает текущую дату	                |SELECT CURRENT_DATE;
----------------------------------------------------------------------------------------
CURRENT_TIME	    |Возвращает текущее время с часовым поясом	|SELECT CURRENT_TIME;
----------------------------------------------------------------------------------------
CURRENT_TIMESTAMP	|Возвращает текущую дату и время с 
                    |часовым поясом	                            |SELECT CURRENT_TIMESTAMP;
------------------------------------------------------------------------------------------
LOCALTIMESTAMP	    |Возвращает текущую дату и время без 
                    |часового пояса	                            |SELECT LOCALTIMESTAMP;
------------------------------------------------------------------------------------------
TO_DATE()	        |Преобразует строку в дату	                |SELECT TO_DATE('2023-01-27', 'YYYY-MM-DD');
-------------------------------------------------------------------------------------------
TO_TIMESTAMP()	    |Преобразует строку в отметку времени	    |SELECT TO_TIMESTAMP('2023-01-27 14:30:00', 'YYYY-MM-DD HH24:MI:SS');
-------------------------------------------------------------------------------------------
EXTRACT()	        |Извлекает отдельные части даты/времени	    |SELECT EXTRACT(YEAR FROM CURRENT_DATE);
------------------------------------------------------------------------------------------
AGE()	            |Вычисляет разницу между датами	            |SELECT AGE('2025-01-27', '2020-01-27');
------------------------------------------------------------------------------------------

ПРИМЕРЫ

Одна из самых простых — это NOW(), которая возвращает текущую дату и время.
SELECT NOW();

________________________________________
Другая полезная функция — AGE(). Она позволяет вычислить разницу между двумя датами 
или временами. Например, вы можете использовать ее, чтобы узнать, сколько времени 
прошло с момента создания заказа.

SELECT AGE(NOW(), '2022-01-01');

____________________________________________________
Функции EXTRACT() или DATE_PART() используются, если нужно извлечь только часть 
даты или времени. Например, чтобы получить год из даты, вы можете сделать так:

SELECT EXTRACT(YEAR FROM NOW());
или
SELECT DATE_PART('year', NOW());        YYYY-MM-DD HH24:MI:SS

___________________________________________________________
Еще одна важная функция — TO_CHAR(), которая позволяет преобразовать дату 
или время в строку в нужном формате. Например, если вы хотите вывести текущую 
дату в формате "день месяц год", вы можете сделать так:

SELECT TO_CHAR(NOW(), 'DD MM YYYY');

______________________________________________________
Наконец, давайте поговорим о функции TO_DATE(), которая позволяет преобразовать 
строку в дату. Это очень полезно, когда вы импортируете данные из внешних источников.

SELECT TO_DATE('2022-01-01', 'YYYY-MM-DD');

____________________________________________________

===========================================================================================
Теперь перейдем к самому интересному — потренируемся в работе с 
функциями даты и времени на данных.

CREATE TABLE my_schema.orders (
   id SERIAL PRIMARY KEY,
   order_date TIMESTAMP NOT NULL,
   product VARCHAR(20) NOT NULL,
   cnt INTEGER NOT NULL,
   price DECIMAL(10, 2) NOT NULL,
   completion_date TIMESTAMP NOT NULL
);
WITH random_values AS (
   SELECT
       ('2024-01-01'::TIMESTAMP + FLOOR(RANDOM() * (90 * 24 * 60)) * INTERVAL '1 minute')::TIMESTAMP AS order_date,
       CONCAT('product', FLOOR(RANDOM() * 9 + 1)::int) AS product,
       FLOOR(RANDOM() * 10) + 1 AS cnt
   FROM
       generate_series(1, 50) AS s(id)
)
INSERT INTO my_schema.orders (order_date, product, cnt, price, completion_date)
SELECT
   rv.order_date,
   rv.product,
   rv.cnt,
   CASE
       WHEN rv.product = 'product1' THEN 8.77
       WHEN rv.product = 'product2' THEN 14.25
       WHEN rv.product = 'product3' THEN 17.20
       WHEN rv.product = 'product4' THEN 39.99
       WHEN rv.product = 'product5' THEN 29.50
       WHEN rv.product = 'product6' THEN 59.99
       WHEN rv.product = 'product7' THEN 65.00
       WHEN rv.product = 'product8' THEN 69.99
       WHEN rv.product = 'product9' THEN 71.99
       ELSE 100
   END AS price,
   rv.order_date + (FLOOR(RANDOM() * 21) + 3) * INTERVAL '1 hour' AS completion_date
FROM
   random_values rv
ORDER BY rv.order_date;

Для того чтобы выполнить весь скрипт целиком можно использовать сочетание 
клавиш Alt + X, либо нажать на «Выполнить SQL скрипт» как показано на примере.

Мы получим таблицу, где: 

id - уникальный идентификатор заказа
order_date - дата заказа

product - категория продукта
cnt - количество заказанного продукта
price - цена продукта за одну единицу
_______________________________________________________________
узнаём сколько времени ушло на обработку заказа
SELECT AGE(o.completion_date, o.order_date) AS processing_time
FROM my_schema.orders o;

____________________________________________
Также узнаем, в какие месяцы совершался заказ. 
Для этого воспользуемся функцией DATE_PART(), в которой укажем'month' 
как часть даты, которую хотим извлечь и столбец с датой заказа (order_date).

SELECT DISTINCT DATE_PART('month', o.order_date) AS order_month
FROM my_schema.orders o;

________________________________________________
Еще мы можем посмотреть, в какие дни совершался заказ. 
Для этого используем функцию TO_CHAR() с форматом 'Day', 
чтобы получить название дня недели.

SELECT o.order_date
,TO_CHAR(o.order_date, 'Day') AS order_day_name
FROM my_schema.orders o;
=========================================================================================

*****************************************************************************************
                Оператор WHERE, логические операторы и операторы IN и BETWEEN
******************************************************************************************

Фильтрация данных — это еще один из наиболее важных аспектов работы с базами данных. 
Фильтрация позволяет выбирать только те данные, которые нам действительно нужны, 
исключая ненужную информацию. В SQL для фильтрации данных используется оператор WHERE, 
который позволяет задавать условия для отбора строк из таблицы.

Оператор WHERE используется для указания условий, которые должны быть выполнены 
для каждой строки, чтобы она была включена в результат запроса. Синтаксис оператора 
WHERE прост:

SELECT что_выбрать FROM откуда_выбрать WHERE условие по которому сделать выбор;

В операторе WHERE часто используются операторы сравнения для задания условий. 
Основные операторы сравнения:
= — равно
> — больше
< — меньше
>= — больше или равно
<= — меньше или равно
<> или != — не равно
_______________________________
SELECT *
FROM my_schema.books b
WHERE b.price = 25.99

 В SQL используются три основных логических оператора:

AND (логическое И) — условие истинно, если оба выражения истинны.
OR (логическое ИЛИ) — условие истинно, если хотя бы одно из выражений истинно.
NOT (логическое отрицание) — инвертирует значение выражения.

__________________________
SELECT *
FROM my_schema.books b
WHERE b.price = 25.99 OR stock > 25;

_____________________________
SELECT *
FROM my_schema.books b
WHERE NOT b.id = 1

SQL-запросы можно выполнять с несколькими условиями, важно понимать, 
в каком порядке они выполняются. В SQL операторы AND и OR имеют определённый приоритет. 
Оператор AND выполняется раньше оператора OR. 
Это означает, что если у вас есть выражение вида A AND B OR C, 
то сначала будет вычислено A AND B, а затем результат будет объединён с C через OR.

_________________________________
SELECT *
FROM my_schema.books b
WHERE b.price > 15 AND b.author = 'Лев Толстой' OR b.price = 12.99;


Для изменения порядка выполнения условий выполним тот же запрос, но с добавлением скобок:

_________________________________________________
SELECT *
FROM my_schema.books b
WHERE b.price > 15 AND (b.author = 'Лев Толстой' OR b.price = 12.99);

С оператором IN это можно сделать гораздо проще, к тому же улучшится читабельность кода:
___________________________________________________
SELECT *
FROM my_schema.books b
WHERE b.stock IN (10, 20);

Оператор BETWEEN используется для проверки, находится ли значение в 
определённом диапазоне. Следует запомнить, что он включает оба граничных значения.

Изменим наш запрос:
_________________________________________________
SELECT *
FROM my_schema.books b
WHERE b.stock BETWEEN 10 AND 20;

==========================================================================================
Важные нюансы
________________
IN: значения в списке должны быть разделены запятыми. 
Если вы используете подзапрос вместо списка значений, 
он должен возвращать только один столбец.

BETWEEN: диапазон включает оба граничных значения. Если вы хотите исключить одно из них, 
используйте операторы > или <.

Практическое применение
________________________
IN: используйте, когда нужно проверить несколько значений одновременно.

BETWEEN: используйте, когда нужно проверить диапазон значений.
==========================================================================================

Когда мы работаем с SQL-запросами, часто нам нужно фильтровать данные по 
определённым критериям. Оператор WHERE позволяет нам делать это, но иногда 
нам нужно искать данные, которые содержат определённые строки или 
соответствуют определённым шаблонам. Для этого в блоке WHERE  
мы можем использовать функции LIKE и ILIKE.
____________________________
SELECT *
FROM my_schema.books b
WHERE b.title like '%и%'

_______________________ чуствителен к регистру
SELECT *
FROM my_schema.books b
WHERE b.title like '%И%'

Если вы хотите найти книги, названия которых начинаются с буквы «и» в любом регистре, 
вам нужно использовать функцию ILIKE, которая не различает регистр.

SELECT *
FROM my_schema.books b
WHERE b.title ilike '%И%'

Также можно учитывать пробелы в словосочетаниях. Например, найдем названия книг, 
где вторым словом будет одна буква «и»:
_______________________________
SELECT *
FROM my_schema.books b
WHERE b.title like '% и %'


============================================================================
Операторы LIKE и ILIKE поддерживает два основных подстановочных символа:

'%' — соответствует любому количеству символов (включая ноль).
'_'— соответствует одному символу.
Шаблон '% и %' можно расшифровать следующим образом:

%: Любое количество символов (включая ноль).
  (пробел): Точный пробел.
и: Точный символ «и».
%: Любое количество символов (включая ноль).
===============================================================================

Также в шаблоне можно указать конкретное количество любых символов перед искомым, например:
_________________________
SELECT *
FROM my_schema.books b
WHERE b.title like '__й%';

Из чего состоит шаблон '__й%':

'_': (подчеркивание): соответствует одному символу. Поскольку подчеркиваний два, 
это означает, что первые два символа в названии книги могут быть любыми.
й: точный символ "й".
%: любое количество символов (включая ноль) после "й".
_____________________________________________
Таким образом, этот шаблон ищет названия книг, которые начинаются с любых двух 
символов, за которыми следует "й", а затем могут быть любые символы.


Оператор WHERE может работать с любыми функциями. Особенно часто условием 
фильтрации выступают дата и время.
Например, найдем только те заказы из таблицы orders, которы были совершены в марте:

SELECT *
FROM my_schema.orders o
WHERE extract(MONTH FROM o.order_date) = 3


*****************************************************************************************
                Операторы ORDER BY, LIMIT и OFFSE
******************************************************************************************

Оператор ORDER BY в SQL используется для сортировки набора результатов запроса 
в порядке возрастания или убывания. Это позволяет организовать данные таким образом, 
чтобы они были более удобны для анализа или отображения.

______________________________
SELECT что выбрать
FROM откуда выбрать
WHERE условие, по которому сделать выбор
ORDER BY как отсортировать данные ASC|DESC

ASC (Ascending) — Сортировка по Возрастанию — используется для сортировки данных 
в порядке возрастания. Это означает, что числа сортируются от меньшего 
к большему (например, 0, 1, 2, 3 и т. д.), а слова — по алфавиту (от А до Я).
Это поведение по умолчанию, поэтому если вы не указываете направление сортировки, 
SQL автоматически использует ASC.
_____________________________
SELECT *
FROM my_schema.orders o
ORDER BY o.cnt;

DESC (Descending) — Сортировка по Убыванию —  используется для сортировки данных 
в порядке убывания. Числа сортируются от большего к меньшему 
(например, 100, 99, 98 и т. д.), а слова — в обратном алфавитном порядке (от Я до А).

___________________________
SELECT *
FROM my_schema.orders o
ORDER BY o.cnt DESC;

Важное замечание! При сортировке по нескольким значениям, приоритет будет 
у того столбца который задан первым, затем по второму и так далее.

======================================
SELECT что выбрать
FROM откуда выбрать
WHERE условие, по которому сделать выбор
ORDER BY как отсортировать данные ASC|DESC
LIMIT сколько первых строк выбрать OFFSET сколько строк нужно пропустить;
============================================

Либо при построении сложного запроса, который так же может вывести 
очень большой результат, можно ограничить вывод с помощью LIMIT.

Пример:
______________________
SELECT *
FROM my_schema.orders o
LIMIT 10;

Оператор OFFSET используется для пропуска определенного количества строк 
перед началом выборки результатов:
___________________________
SELECT *
FROM my_schema.orders o
OFFSET 39;

Очень часто OFFSET используются вместе с LIMIT, они позволяют 
реализовать постраничное отображение данных:
________________________________
SELECT *
FROM my_schema.orders o
LIMIT 10
OFFSET 0; --далее 10, 20, 30 и т.д.

============================================================
Хотя OFFSET полезен для пагинации, он может быть неэффективным для больших таблиц, 
поскольку требует полного сканирования таблицы для пропуска строк. 
Это может привести к замедлению производительности, особенно при работе с 
большими объемами данных.
=============================================================



************************************************************************************
                               практические задания
************************************************************************************

___________________________________________
Таблица interview_results:
Содержит результаты тестовых собеседований, проходящих в рамках курсов 1T.Data. 
Каждая запись в таблице содержит информацию о пользователе, курсе, времени начала 
собеседования, балле полученном при прохождении, времени, затраченном на собеседование, 
и статусе результата. Данные генерируются случайным образом для имитации реальных условий.

________________________________________
CREATE TABLE interview_results (
   id SERIAL PRIMARY KEY,
   user_id VARCHAR(10),
   course_id INT,
   start_time TIMESTAMP,
   score INT,
   time_taken BIGINT, 
   result_status BOOLEAN
);
INSERT INTO interview_results (id, user_id, course_id, start_time, score, time_taken, result_status) VALUES
(1, 'user245', 2, '2024-11-04 17:14:00.000', 85, 4860, true),
(2, 'user402', 3, '2024-11-01 16:10:00.000', 89, 2700, true),
(3, 'user307', 1, '2024-11-03 17:48:00.000', 95, 4320, true),
(4, 'user615', 4, '2024-11-03 17:26:00.000', 89, 4860, true),
(5, 'user603', 1, '2024-11-05 16:16:00.000', 89, 2580, true),
(6, 'user056', 3, '2024-11-05 17:31:00.000', 93, 4740, true),
(7, 'user003', 3, '2024-11-01 16:27:00.000', 84, 3240, true),
(8, 'user155', 2, '2024-11-01 17:21:00.000', 91, 2520, true),
(9, 'user943', 2, '2024-11-02 17:43:00.000', 92, 2700, true),
(10, 'user920', 3, '2024-11-05 16:09:00.000', 94, 4080, true),
(11, 'user511', 2, '2024-11-05 16:24:00.000', 92, 3840, true),
(12, 'user422', 4, '2024-11-05 16:09:00.000', 99, 4380, true),
(13, 'user538', 1, '2024-11-03 17:21:00.000', 93, 4500, true),
(14, 'user291', 4, '2024-11-04 16:45:00.000', 21, 2880, false),
(15, 'user043', 4, '2024-11-05 16:14:00.000', 86, 3660, true),
(16, 'user257', 1, '2024-11-02 17:56:00.000', 84, 5160, true),
(17, 'user276', 4, '2024-11-03 17:05:00.000', 83, 3300, true),
(18, 'user846', 1, '2024-11-01 17:56:00.000', 95, 3540, true),
(19, 'user113', 3, '2024-11-03 16:25:00.000', 4, 4920, false),
(20, 'user266', 2, '2024-11-03 17:29:00.000', 85, 3240, true),
(21, 'user738', 3, '2024-11-01 16:42:00.000', 97, 5100, true),
(22, 'user070', 4, '2024-11-02 16:21:00.000', 71, 3120, false),
(23, 'user221', 2, '2024-11-04 16:22:00.000', 82, 4980, true),
(24, 'user105', 2, '2024-11-04 16:15:00.000', 41, 5160, false),
(25, 'user593', 3, '2024-11-01 16:38:00.000', 93, 4380, true),
(26, 'user895', 4, '2024-11-01 17:41:00.000', 86, 3720, true),
(27, 'user790', 3, '2024-11-05 16:01:00.000', 86, 3300, true),
(28, 'user245', 2, '2024-11-03 17:28:00.000', 88, 3420, true),
(29, 'user397', 4, '2024-11-05 17:45:00.000', 48, 4980, false),
(30, 'user302', 5, '2024-11-05 17:28:00.000', 99, 4080, true),
(31, 'user915', 1, '2024-11-04 17:38:00.000', 81, 2940, true),
(32, 'user694', 1, '2024-11-05 17:01:00.000', 94, 4080, true),
(33, 'user940', 1, '2024-11-02 16:43:00.000', 84, 4920, true),
(34, 'user095', 1, '2024-11-01 17:19:00.000', 80, 3420, true),
(35, 'user532', 2, '2024-11-03 16:26:00.000', 39, 4740, false),
(36, 'user439', 4, '2024-11-01 16:33:00.000', 82, 5040, true),
(37, 'user877', 5, '2024-11-05 17:31:00.000', 87, 3540, true),
(38, 'user812', 2, '2024-11-04 17:07:00.000', 87, 5220, true),
(39, 'user116', 3, '2024-11-02 16:57:00.000', 98, 5340, true),
(40, 'user429', 2, '2024-11-04 17:34:00.000', 90, 5220, true),
(41, 'user534', 1, '2024-11-05 17:29:00.000', 82, 2580, true),
(42, 'user730', 5, '2024-11-01 17:57:00.000', 98, 3660, true),
(43, 'user129', 2, '2024-11-01 16:30:00.000', 33, 4560, false),
(44, 'user668', 2, '2024-11-03 16:33:00.000', 67, 4200, false),
(45, 'user898', 5, '2024-11-03 16:23:00.000', 91, 3960, true),
(46, 'user801', 3, '2024-11-04 17:41:00.000', 98, 2700, true),
(47, 'user123', 4, '2024-11-04 17:56:00.000', 96, 2760, true),
(48, 'user714', 1, '2024-11-05 16:08:00.000', 18, 3180, false),
(49, 'user519', 3, '2024-11-03 17:41:00.000', 80, 5220, true),
(50, 'user778', 1, '2024-11-04 16:26:00.000', 93, 4080, true),
(51, 'user014', 5, '2024-11-03 16:36:00.000', 91, 3840, true),
(52, 'user993', 1, '2024-11-01 16:11:00.000', 97, 2520, true),
(53, 'user347', 1, '2024-11-04 16:09:00.000', 82, 4560, true),
(54, 'user882', 3, '2024-11-03 16:43:00.000', 81, 2460, true),
(55, 'user004', 2, '2024-11-04 16:32:00.000', 97, 3060, true),
(56, 'user726', 3, '2024-11-03 16:58:00.000', 96, 3180, true),
(57, 'user147', 5, '2024-11-05 17:51:00.000', 85, 4740, true),
(58, 'user828', 1, '2024-11-05 17:25:00.000', 88, 5220, true),
(59, 'user757', 4, '2024-11-04 17:48:00.000', 86, 3300, true),
(60, 'user272', 5, '2024-11-03 16:14:00.000', 84, 3720, true),
(61, 'user931', 4, '2024-11-05 16:27:00.000', 58, 5280, false),
(62, 'user696', 5, '2024-11-02 17:16:00.000', 83, 3780, true),
(63, 'user822', 1, '2024-11-02 17:37:00.000', 86, 4260, true),
(64, 'user771', 5, '2024-11-05 17:51:00.000', 86, 3720, true),
(65, 'user480', 5, '2024-11-05 16:58:00.000', 93, 3420, true),
(66, 'user749', 3, '2024-11-03 17:10:00.000', 85, 5280, true),
(67, 'user661', 4, '2024-11-03 16:33:00.000', 54, 4080, false),
(68, 'user567', 2, '2024-11-01 16:07:00.000', 84, 4440, true),
(69, 'user746', 1, '2024-11-01 16:30:00.000', 93, 3960, true),
(70, 'user208', 2, '2024-11-04 17:33:00.000', 80, 2580, true),
(71, 'user752', 3, '2024-11-03 16:37:00.000', 93, 2880, true),
(72, 'user288', 2, '2024-11-02 17:58:00.000', 83, 2640, true),
(73, 'user788', 3, '2024-11-03 16:04:00.000', 93, 4020, true),
(74, 'user907', 3, '2024-11-02 16:05:00.000', 80, 2640, true),
(75, 'user377', 4, '2024-11-04 17:00:00.000', 93, 5220, true),
(76, 'user684', 3, '2024-11-03 16:48:00.000', 83, 5100, true),
(77, 'user526', 1, '2024-11-05 16:56:00.000', 87, 4920, true),
(78, 'user870', 3, '2024-11-01 17:06:00.000', 87, 5280, true),
(79, 'user239', 4, '2024-11-03 17:34:00.000', 97, 4320, true),
(80, 'user950', 2, '2024-11-04 16:19:00.000', 99, 4920, true),
(81, 'user837', 5, '2024-11-02 16:47:00.000', 54, 2520, false),
(82, 'user567', 4, '2024-11-04 16:49:00.000', 86, 4980, true),
(83, 'user387', 3, '2024-11-03 17:53:00.000', 82, 2400, true),
(84, 'user883', 5, '2024-11-04 17:09:00.000', 88, 2880, true),
(85, 'user744', 5, '2024-11-01 16:48:00.000', 95, 4740, true),
(86, 'user262', 5, '2024-11-03 16:01:00.000', 89, 3360, true),
(87, 'user251', 2, '2024-11-04 17:36:00.000', 87, 3480, true),
(88, 'user572', 3, '2024-11-03 17:39:00.000', 86, 5340, true),
(89, 'user065', 1, '2024-11-05 16:49:00.000', 85, 4980, true),
(90, 'user018', 5, '2024-11-05 17:23:00.000', 68, 2760, false),
(91, 'user909', 1, '2024-11-01 17:31:00.000', 99, 3780, true),
(92, 'user117', 4, '2024-11-04 16:54:00.000', 90, 3420, true),
(93, 'user586', 4, '2024-11-04 17:28:00.000', 98, 3420, true),
(94, 'user941', 3, '2024-11-05 17:42:00.000', 67, 2760, false),
(95, 'user974', 4, '2024-11-05 16:50:00.000', 75, 2700, false),
(96, 'user698', 1, '2024-11-02 16:34:00.000', 18, 4440, false),
(97, 'user112', 5, '2024-11-01 17:59:00.000', 83, 5340, true),
(98, 'user517', 3, '2024-11-01 17:54:00.000', 87, 4140, true),
(99, 'user615', 1, '2024-11-04 16:23:00.000', 34, 4200, false),
(100, 'user297', 5, '2024-11-01 17:00:00.000', 92, 3780, true);
======================================================================
Выведите все строки из таблицы interview_results, где score больше 90.
___________________________________________
select * from my_schema.interview_results ir 
where ir.score > 90; 
=========================================================================
Выведите user_id, course_id и score для всех студентов из таблицы 
interview_results которые прошли собеседование. Данные отсортируйте по score.
________________________________________
select user_id
, course_id
, score from my_schema.interview_results ir 
where result_status = true order by ir.score;
==============================================================================
Выведите все записи из таблицы interview_results, 
где время собеседования было более 45 минут.
Подсказка: в этой задаче мы работаем с форматом Unix timestamp — 
это число секунд, прошедших с начала эпохи Unix (00:00:00 UTC, 1 января 1970 года), 
чтобы выбрать записи, где время собеседования превышает 45 минут, 
используйте умножение на 60 для перевода минут в секунды.

_____________________________________________
select * from interview_results ir where (ir.time_taken / 60) > 45;
==================================================================================
Выведите первые десять строк user_id, course_id, score и time_taken 
в минутах (столбец назовите minutes) для студентов из таблицы interview_results 
у которых  score больше 80 и time_taken больше одного часа.
______________________________________________
select user_id
, course_id
, score
, ir.time_taken / 60 as "minutes" from my_schema.interview_results ir
where score > 80 and (ir.time_taken / 60) > 60
limit 10;
===================================================================================
Выведите user_id, course_id, score и time_taken в минутах 
(столбец назовите time taken minutes),  
для всех студентов из таблицы interview_results, 
где score между 70 и 90 и time_taken больше одного часа. 
Полученный результат отсортируйте по score в порядке убывания.
_________________________________________
select user_id
, course_id
, score
, ir.time_taken / 60 as "time taken minutes" from interview_results ir
where ir.score between 70 and 90 and (ir.time_taken / 60) > 60
order by ir.score desc;
===================================================================================
Выведите user_id, course_id, score и time_taken для всех записей 
в таблице interview_results, где score больше 80, 
а time_taken меньше 3600 секунд (1 час). 
Отсортируйте результат по score в порядке убывания.
__________________________________________
select user_id
, course_id
, score
, time_taken from interview_results ir 
where ir.score > 80 and ir.time_taken < 3600
order by ir.score desc;
=====================================================================================
Выведите user_id, score и start_time 
в таблице interview_results, где время начала собеседования 
находится между 16:00 и 18:00. 
Отсортируйте результаты по времени начала собеседования.
______________________________________________________________
ХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ
ХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ
ХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ

========================================================================================
Выведите user_id, course_id, score и time_taken для всех записей 
в таблице interview_results, где result_status равен FALSE 
(собеседование не пройдено), а time_taken больше 3000 секунд (50 минут). 
Отсортируйте результат по time_taken в порядке возрастания.

____________________________________________________________________
select user_id, course_id, score, time_taken from interview_results ir
where ir.result_status = false and ir.time_taken > 3000
order by ir.time_taken asc;

===================================================================================
Выведите id и время собеседования в формате "часы минуты" 
(столбец назовите time_taken) для всех записей в таблице interview_results.
___________________________________________________________
select 
TO_CHAR(start_time, 'HH24ч MIм') as time_taken
from my_schema.interview_results ir; 

____________________________________________________________
select
CONCAT(DATE_PART('hour', start_time), 'ч', DATE_PART('minute', start_time), 'м') as time_taken
from my_schema.interview_results ir; 

Выведите id, время собеседования в часах(столбец назовите hours) 
и минутах (столбец назовите minutes) для 10 записей в таблице interview_results, 
начиная с 11-й записи.
_______________________________________________________________________
select
DATE_PART('hour', start_time) as hours,
DATE_PART('minute', start_time) as minute
from my_schema.interview_results ir
LIMIT 10 OFFSET 10;





"""























