"""
Selenium - это проект который предназначен главным образом для автоматизации тестирования
веб-приложений.

Selenium WebDriver - универсальный интерфейс (не важно на каком языке программировании)
"""


"""
Поиск элементов с помощью Selenium

Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, позволяющих искать по атрибутам элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Для поиска Selenium предоставляет метод find_element, который принимает два аргумента - тип локатора и значение локатора. Существуют следующие методы поиска элементов:

find_element(By.ID, value) — поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
find_element(By.CSS_SELECTOR, value) — поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
find_element(By.XPATH, value) — поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
find_element(By.NAME, value) — поиск по атрибуту name элемента;
find_element(By.TAG_NAME, value) — поиск элемента по названию тега элемента;
find_element(By.CLASS_NAME, value) — поиск по значению атрибута class;
find_element(By.LINK_TEXT, value) — поиск ссылки на странице по полному совпадению;
find_element(By.PARTIAL_LINK_TEXT, value) — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.
"""
# import time
# from selenium import webdriver
# from selenium.webdriver.common.by import By
#
# browser = webdriver
# browser.get("http://suninjuly.github.io/simple_form_find_task.html")
#
# button = browser.find_element(By.ID, "submit_button").text
#
# print(button)
#
# time.sleep(10)

#--------------------------------------------------ущё варик
# import time
#
# from selenium import webdriver
# from selenium.webdriver.common.by import By
#
# driver = webdriver.Chrome()
#
#
# time.sleep(5)
# driver.get("https://suninjuly.github.io/text_input_task.html")
# time.sleep(5)
#
# #нахождение элемента
# textarea = driver.find_element(By.CSS_SELECTOR, ".textarea")
# # Напишем текст ответа в найденное поле
# textarea.send_keys("get()")
# time.sleep(5)
#
# # Найдем кнопку, которая отправляет введенное решение
# submit_button = driver.find_element(By.CSS_SELECTOR, ".submit-submission")
#
# # Скажем драйверу, что нужно нажать на кнопку. После этой команды мы должны увидеть сообщение о правильном ответе
# submit_button.click()
# time.sleep(5)
#
# # После выполнения всех действий мы должны не забыть закрыть окно браузера
# driver.quit()


"""
Поиск элементов с помощью CSS-селекторов
Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

id
tag
значение атрибута
name
class

Поиск осуществляется нажатием клавиши при открытой консоли ctr-f

Поиск по id
Какое везение! У элемента с нашей картинкой есть атрибут id="bullet", а значит, 
мы однозначно можем найти её с помощью селектора #bullet (знак # означает, 
что мы ищем по id со значением bullet).

Поиск по значению атрибута
Можно найти элемент, указав название атрибута и его значение. 
Например, можно переписать поиск по id в следующем виде [id="bullet"] вместо #bullet.

Лучше использовать вариант с квадратными скобками при поиске значения 
атрибута для тех атрибутов, у которых нет собственных коротких команд поиска. 
Например, давайте найдем элемент h1 по значению его атрибута value: [value="Cat memes"].


Поиск по name
Этот вариант поиска является разновидностью поиска по значению атрибута и 
записывается так же: [name="bullet-cat"]. Мы выделяем этот вариант потому 
что он довольно часто используется, а также выделяется как отдельный вид поиска 
элементов в Selenium WebDriver.


Поиск по class
Поиск по классу можно записать в виде [class="jumbotron-heading"], 
так как class тоже является атрибутом элемента. Но раз уж классы используются 
практически в каждой странице при задании стилей страниц, то для них также имеется 
свой короткий вариант поиска: .jumbotron-heading. То есть мы пишем значение класса 
и предваряем его точкой.

Вариант .lead при этом позволит найти данный элемент, 
так как он ищет простое вхождение класса в элемент. Для уточнения селектора 
можно задать также оба класса, для этого нужно добавить второй класс к строке поиска 
без пробела и предварить его точкой: .lead.text-muted. Порядок классов в отличие от 
первого способа здесь не важен — .text-muted.lead так же найдет нужный элемент. 
Рекомендуем пользоваться вторым способом поиска классов, так как он является более гибким.
"""

"""
Поиск элементов с помощью составных CSS-селекторов

Попробуем найти элемент с текстом "Ходили купаться". 
Для решения этой задачи мы можем взять элемент, стоящий выше в иерархии нужного нам элемента, и написать следующий селектор:

#post2 .title
Здесь символ # означает, что надо искать элемент с id post2, 
пробел - что также нужно найти элемент-потомок, а ., что элемент-потомок 
должен иметь класс со значением title.

Использование дочерних элементов

Другой способ найти этот элемент:
#post2 > div.title
Здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент 
с тегом и классом: div.title, который находится строго на один уровень 
иерархии ниже чем элемент #post2. Для этого используется символ >

Использование порядкового номера дочернего элемента

Еще один способ найти этот элемент:
#posts > .item:nth-child(2) > .title
Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент 
среди дочерних элементов для #posts. Затем с помощью конструкции > .title мы указываем, 
что нам нужен элемент .title, родителем которого является найденный ранее элемент .item.


Использование нескольких классов

Также мы можем использовать сразу несколько классов элемента, 
чтобы его найти. Для этого классы записываются подряд через точку: .title.second

#moto       Поиск по ID
article     Поиск по tag
[title="one-thing"]    Поиск по attribute 
[name="moto"]          Поиск по name 
.lead                  Поиск по class 
article.text-muted.lead        Поиск по составному CSS-селектору 

"""
"""
2. Символ [ ] — это команда фильтрации
Если по запросу найдено несколько элементов, т
о будет произведена фильтрация по правилу, указанному в скобках.

Правил фильтрации очень много:

по любому атрибуту, будь то id, class, title (или любой другой). 
Например, мы хотим найти картинку с летящим котом, для этого можно 
выполнить запрос //img[@id='bullet']
по порядковому номеру. 
Допустим, мы хотим выбрать вторую по порядку карточку с котом. 
Для этого найдем элемент с классом "row" и возьмем его второго потомка: 
//div[@class="row"]/div[2]
по полному совпадению текста. Да, XPath — это единственный способ найти элемент 
по внутреннему тексту. Если мы хотим найти блок текста с котом-Лениным, 
можно воспользоваться XPath селектором //p[text()="Lenin cat"]. 
Такой селектор вернет элемент, только если текст полностью совпадет. 
Здесь важно сказать, что не всегда поиск по тексту — это хорошая практика, 
особенно в случае мультиязычных сайтов.
по частичному совпадению текста или атрибута.
Для этого нужна функция contains. Запрос //p[contains(text(), "cat")] 
вернет нам все абзацы текста, которые содержат слово cat. 
Точно так же можно искать по частичному совпадению других атрибутов, 
это удобно, если у элемента несколько классов. Посмотрите на код навбара 
сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]
в фильтрации еще можно использовать булевы операции (and, or, not) 
и некоторые простые арифметические выражения (но вообще не стоит, наверное). 
Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat", 
для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']
"""


#body > div > div:nth-child(2) > div > button:nth-child(2)




















